\section{Ausiello Algorithm: Implementation}

\subsection{Data Structure}

\subsubsection{Recall the theoretical structure}

In this paragraph, we will recall essential elements of an FD-Graphs, namely
the possible arcs, the structure we may need to compute closure and so forth.

\subsubsection{Code definition}

The algorithms are given in terms of the size of an FD-graph. In 
\cite{ausiello_minimal_1986}, one can read that this size is assumed to be the
size of a graph under adjacency list representation. Using a matrix based 
structure would take a quadratic amount of memory, and would be less efficient
for adding/removing nodes, unmatching theoretical complexity. In the next
paragraphs, we will explain more precisely the structure we chosen.

\vspace{1.2em}

An FD-Graph can have two types of nodes (simple, compound), and up to 5 type
of arcs (full, dotted, closed full, closed dotted, D). Furthermore, for closure
and marking purposes, each vertex must have a counter embedded. Finally, we
are supposed to build a graph out of an implication system based on 
\lil{BitSet}. Hence, to ease conversion and computations, we label each vertex
by its \lil{BitSet} representation. Eventually, a vertex will be defined as in 
the following snippet:

\begin{lstlisting}[language=CoreCpp, style=Light, breaklines=true]
typedef struct vertex vertex_t;

struct vertex{
  std::map<std::string, std::list<elt_t *>> edges;
  unsigned int counter;
};

typedef std::pair<FCA::BitSet, vertex_t> elt_t;

\end{lstlisting}

\noindent Where \lil{elt_t} will be elements stored in the overhaul graph 
structure, being only a list of \lil{elt_t}:

\begin{lstlisting}[language=CoreCpp, style=Light, breaklines=true]
typedef std::list<elt_t> graph;
\end{lstlisting}

\noindent Note that we use pointer on adjacent nodes to represent edges 
(\lil{std::list<elt_t *>}). This avoids duplication of \lil{BitSet}, ease use 
of counters and allow for fast access to one node to a given adjacent one. The 
\lil{map} structure deserves to represent all type of edges a vertex can have.
We prefered \lil{map} instead of say \lil{list} or \lil{vector} for the 
trade-off between access and code readability. Having string keys makes the code
clearer, while keeping a logarithmic access time to a given list. Because the 
number of list is constant, the excess of computations with respect to a 
\lil{vector} is negligible. 

\vspace{1.2em}

In order to illustrate, we give an example of a simple basis $ab \imp c$ 
represented through FD-Graph both graphically and with our data structure in
figure \ref{fig:Graph-DS}. In this figure "\&" stands for the \belemp{address}
of following vertex. Also, for sake of clarity we did not drawn the closure of 
the graph nor the counters. Only initial arcs are represented: dotted, full and 
D ones. 
 

\begin{figure}[ht]
	\input{Pictures/Graph-DS.tex}
	\label{fig:Graph-DS}
\end{figure}

Note that due to lack of time, this is the only structure we provided. Here are
some ideas and points that one should read in regard to implement another 
structure for representing FD-Graphs. First recall that the graph should have
a space complexity in $O(|\I|)$ according to Ausiello and al. (see 
\cite{ausiello_minimal_1986}). In this paper, implication basis are provided
under hypergraphs framework and the size $|\I|$ of $\I$ is the size of the 
structure in terms of adjacency lists. Fortunately, whether we consider 
hypergraphs or usual set notations, $|I|$ is still $O(|B||\Sg|)$ since we 
have $|B|$ hyperarcs, going to at most $|\Sg|$ single attributes (under reduced
form). The size of the associated FD-Graph should be linear in the size $\I$.

\vspace{1.2em}

We are going to investigate our structure. Because we made a structure supposed
to store the closure of a graph also, we will study here the space used only
for representation of the FD-Graph (simple/compound nodes, and dotted/full 
arcs) to be fair in comparison:
\begin{itemize}
	\item We have $O(|\Sg| + |B|)$ nodes,
	\item we will have full arcs to single attributes for bodies only, 
	that is, $O(|B||\Sg|)$ = $O(|I|)$ space complexity,
	\item we will have dotted arcs only from compound bodies of $\I$ to 
	single attributes, also resulting in $O(|I|)$ space complexity,
	\item for each dotted arc, we will have a D-arc, hn
\end{itemize}

\subsubsection{A quick overview of complexity}





















